# System Design Document – Study Buddy (AI Assignment Planner + Doubt Solver)

**Author:** Md Umair Alam  
**University:** IIT Delhi (Biotechnology and Biochemical Eng.)  
**Repository:** [Study Buddy GitHub Repo](https://github.com/Umair-IITD/Study-Buddy)  
**Deployed App:** [Study Buddy on Vercel](https://study-buddy-two-navy.vercel.app)  
**Date:** 18th September 2025  

---

## 1. Purpose & Goals

**Purpose:**  
Build an AI agent prototype — **Study Buddy** — that helps students with assignment guidance, topic explanations, and personalized study planning/scheduling.

**Goals (assignment-aligned):**
- Demonstrate an agent that can reason, plan and execute to automate a manual task (study planning).
- Provide a user interface (chat UI) for interaction.
- Produce deliverables: source code, system design doc, interaction logs, optional demo.

**Non-goals (explicit):**
- Not intended as a medical/diagnostic tool.
- Not production-level user management or scale-out infrastructure (unless extended).

---

## 2. Functional Requirements
1. Chat UI where users ask questions or request study plans.  
2. Agent uses system prompt (`StudyBuddyInfo.js`) + chat history to produce domain-specific replies.  
3. Generate study plans and schedules given user constraints (classes, labs, gym, free slots).  
4. Provide worked-out examples (e.g., math) with step-by-step solutions.  
5. Save interaction logs for submission and debugging.  
6. *(Optional bonus)* Planner & Executor separation (two-agent pattern), task storage, reminders, and dashboard.  

---

## 3. Non-Functional Requirements
- **Response time:** < 3s typical; handle longer gracefully (loading state).  
- **Availability:** Deployed on Vercel; tolerate occasional LLM 503 errors with retry/backoff.  
- **Security:** API keys stored as environment variables (not committed).  
- **Maintainability:** Clear component separation, documented APIs.  
- **Testability:** Unit + integration + manual acceptance tests documented.  

---

## 4. High-Level Architecture

```text
[User Browser] 
     |
     | (HTTP: chat requests UI)
     v
 [Frontend: React + Vite]  
     |
     | --(1) calls-->  [/api/generate (Serverless Endpoint)]  
     |                        |
     |                        v
     |                [Google Gemini API]
     |                        |
     v                        v
 LocalStorage            (optional) DB (Supabase/Firebase)
 (chatHistory, tasks)     Monitoring (Sentry, Vercel logs)
```

Flow:

1. User types a query → frontend formats request (prepends StudyBuddyInfo system context optionally) and calls /api/generate.
2. Serverless function receives request, reads server-side environment key, and calls Gemini.
3. Response returned to frontend → UI updates chat and optionally persists logs/tasks.

Why serverless?
- Prevents exposing API key in client.
- Straightforward with Vercel serverless functions.
- Minimal infra.

---

## 5. Component Breakdown

**Frontend (React + Vite)**

- App.jsx — main logic (chat history state, scroll behavior).
- ChatForm.jsx — input handling + “Thinking…” state.
- ChatMessage.jsx — render messages.
- StudyBuddyInfo.js — system prompt (persona + feature list).
- index.css — styling.
- Responsibilities: format requests, display results, store logs locally, call backend endpoints.

**Backend (Serverless / Node API)**

- /api/generate — receives chat history, forwards to Gemini with server-side API key.
- /api/tasks — CRUD for planner tasks (optional).
- /api/logs — store interaction logs (optional).
- Responsibilities: secure API key usage, retries/backoff, validate inputs.

**AI Layer**

- Google Gemini (gemini-2.5-flash) is used.
- System prompt (StudyBuddyInfo.js) supplies persona/context.

**Persistence (Optional)**

- LocalStorage (default): saves chatHistory + tasks.
- DB (optional): Supabase / Firebase / SQLite for persistent storage.

---

## 6. Data Design — Models & Schema

**ChatMessage**
```bash
{
  "id": "uuid",
  "role": "user" | "model",
  "text": "string",
  "timestamp": "2025-08-24T17:02:41.000Z"
}
```
**Task (Study Task)**
```bash
{
  "id": "uuid",
  "title": "Revise Linear Algebra",
  "description": "Matrices and determinants",
  "start": "2025-08-25T11:00:00Z",
  "end": "2025-08-25T13:00:00Z",
  "priority": "high",
  "status": "todo" // todo | done | in-progress
}
```
**Plan Object (Generated by Agent)**
```bash
{
  "planId": "uuid",
  "createdAt": "...",
  "schedule": [
    { "start": "09:00", "end": "10:30", "activity": "Math: integrals" }
  ],
  "notes": "Pomodoro 25/5 recommended"
}
```
**Interaction Log Format**
```bash
[
  {
    "user": "Can you help me solve 2x + 5 = 15?",
    "bot": "x = 5 (explanation...)",
    "timestamp": "2025-08-24T17:02:41.000Z"
  }
]
```
---

## 7. Interaction Flow

1. User types message in ChatForm.
2. Frontend appends message to chatHistory (role=user).
3. Frontend sends POST /api/generate with history (prepend system prompt).
4. Serverless forwards to Gemini with secret key.
5. Gemini responds → serverless returns response.
6. Frontend updates chatHistory with model response (role=model).
7. UI scrolls to bottom; logs optionally saved.

---

## 8. Error Handling & Reliability

**503 / Model Overloaded**

- Retry with exponential backoff: wait = base * 2^attempt (base=500ms, attempts=3).
- Graceful fallback: “Model busy — trying again…” message.
- Queue requests locally and replay.
- Log errors (console + optional Sentry).

---

## 9. Security & Privacy

- API keys stored in Vercel environment variables (GEMINI_API_KEY).
- No .env committed to repo.
- CORS restricted to frontend origin.
- No sensitive PII stored.
- Rotate API keys if compromised.
- Disclaimer in UI: correctness + plagiarism avoidance.

---

## 10. Monitoring & Observability

- Logs: Vercel serverless + client console.
- Error tracking: Sentry for frontend.
- Metrics:
    - Requests per minute.
    - 503 error rate.
    - Average latency.
- Alerts: Trigger if repeated 503s or high error rates.

---

## 11. Testing & QA

**Unit Tests**
- Components: ChatMessage, ChatForm.
- Utils: history formatting, response parsing.

**Integration Tests**
- Mock serverless function (MSW).

**E2E Tests**
- Playwright/Cypress to simulate chat sessions.

**Manual Acceptance Scenarios**
1. Ask a math problem → verify correct explanation.
2. Provide schedule → verify 2hr study plan generated.
3. Simulate Gemini 503 → verify retry/backoff UI.

---

## 12. Deployment & CI/CD

**Deployment (Vercel)**

1. Push repo to GitHub.
2. Import in Vercel dashboard → New Project.
3. Add env variables:
    - GEMINI_API_KEY
    - VITE_API_URL
4. Build: npm run build (Vite → dist/).
5. Deploy.

**CI/CD**

- Vercel auto-deploys on GitHub push.
- GitHub Actions (optional): run lint + tests before deploy.

---

## 13. Persistence & Scaling Roadmap

- Short term: LocalStorage persistence.
- Mid term: Supabase / Firebase for accounts & tasks.
- Long term:
    - RAG pipeline (vector DB like Pinecone).
    - Multi-agent pipeline (Planner + Executor).
    - Scheduled worker for reminders.
    - Redis queue for scaling.
